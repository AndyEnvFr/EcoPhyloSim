#' @title Plot Phylogenetic Dispersion
#' @description Plotting function for the results of \code{\link{calculatePhylogeneticDispersion}}. It is used to compare different scenarios.
#' @param pvalues List of p-values as generated by \code{\link{calculatePhylogeneticDispersion}}.
#' @param positions List, determines where the plots should be placed and how they should be labeled (see Details). The list need to have the entries x, y, xname and yname.
#' @param title String, determines the title of the plot
#' @param which.result Integer, determines which result should be used. By default (NULL), the last result is used.
#' @param xmax Float, determines the plot limit (max) of the x axis.
#' @param ymax Float, determines the plot limit (max) of the y axis.
#' @param xmin Float, determines the plot limit (min) of the x axis.
#' @param ymin Float, determines the plot limit (min) of the y axis.
#' @details In every subplot the x-axis represents the size of the subplots used in the null models. Hence, it is recommended to use a vector of plot sizes in your \code{\link{calculatePhylogeneticDispersion}} setup. \cr\cr The which.result argument here is used on the input list of p-values. Hence, which.result = 1 plots the first list slice of the input here. This is not necessarily the first time step of of your parameter settings in \code{\link{runSimulationBatch}}. \cr\cr For an further explanation please see the Examples section. 
#' @examples 
#' ## First the experimental design has to be defined.
#' ## In this example we will test seven different combinations of the parameters
#' ## 'density and 'environment' under four different dispersal distances.
#' ## This design leads to 28 experiments.
#'   
#' dispOptions <- 4
#' fitOptions <- 7
#'
#' # These are the parameters that are tested.  
#' # We are testing seven combinations of the parameters 'density' and 'environment'...
#' density <- rep(c(0,seq(0,1,len = fitOptions-2),1),dispOptions)
#' environment <- rep(c(0,seq(1,0,len = fitOptions-2),1),dispOptions)
#' 
#' # ... for four different dispersal ranges.
#' dispersal <-  rep(c(0,0.5, 2,4), each = fitOptions)
#' 
#' ## The modes and scenarios are only defined to label the plots. They have no influence on the 
#' ## calculations.
#' modes <- ifelse(dispersal == 0, "global", "local")
#' scenarios <- paste(modes, " dens=", density, " env=", environment, sep = "")
#' 
#' ## Now we can define a list of parameter sets.
#' pars <- list()
#' for (i in 1:length(scenarios)){pars[[i]] = createCompletePar(x = 20,y = 20, runs = 1000,scenario = scenarios[i], dispersal = dispersal[i],specRate = 2,density = density[i],environment = environment[i], fitnessBaseMortalityRatio = 5, densityCut = 1,seed = 1000)}
#' 
#' ## Run the simulations
#' simulationOut <- runSimulationBatch(pars, parallel = 2)
#' 
#' ## Calculate null models. For each model run 9 plot sizes are tested. In the plot they are 
#' ## used to calculate the confidence interval for the results.
#' nullMeta <- calculatePhylogeneticDispersion(simulationOut, plotlengths = c(2,3,4,5,6,7,8,9,10), reduce = TRUE)
#' 
#' ## Now we can define the positions and labels of the plots.
#' ## Note that here the 28 simulations need to be covered in the right order. 
#' ## In this example there will be 7 rows and 4 collumns to represent the 28 cases.
#' positions <- list(x= c(1:7),
#'    y = c(4, 1:3), # this is beacause dispersal = "global" is equal to dispersal = "0"
#'    zname = c("neutral", "1", "0.75", "0.5", "0.25", "0", "both"), # = environment
#'    yname = c("global", "0.5", "2", "4"),  # = dispersal
#'    xname=c("neutral", "0", "0.25", "0.5","0.75","1","both")) # = density
#' 
#' ## Now you can plot the results.
#' plotPhylogeneticDispersion(pvalues = nullMeta, positions = positions, title = "Null Meta")
#' 
#' @export
#' 
plotPhylogeneticDispersion <- function(pvalues, positions=NULL, title = "P-values", which.result = NULL, xmax = 5.5, ymax = 2.5, xmin = -0.2, ymin = 0.5){
  
  .pardefault <- par(no.readonly = T) 
  
  if(is.null(which.result)){
    pvalues<-pvalues[[length(pvalues)]]
    } else{
    pvalues <- pvalues[[which.result]]
    } 
  
  if (is.null(positions)){
    stop("Error. No positions defined.")
  }  
  xcol <- length(positions$x)
  ycol <- length(positions$y)
  lengths = as.numeric(names(pvalues[[1]]))
  nlengths = length(lengths)
  lRange <- max(lengths) - min(lengths)
  
  z <- matrix(nrow = nlengths, ncol = length(pvalues), 
              dimnames = list(names(pvalues[[1]]), names(pvalues)))
  zCILOW <- z
  zCIUP <- z
  for (i in 1:length(pvalues)){
    z[,i] <- sapply(pvalues[[i]], median, na.rm = T)
    zCILOW[,i] <- sapply(pvalues[[i]], function(x)quantile(x,0.25, na.rm = T))   
    zCIUP[,i] <- sapply(pvalues[[i]], function(x)quantile(x,0.75, na.rm = T))
  }
  
  ColPalet <- colorRampPalette(c("turquoise4", "white", "palevioletred"))
  Cols <- ColPalet(100)
  index <- seq(0,1,0.01)
  par(mar=c(0, 3, 0, 0), xpd=TRUE)
  shape::emptyplot(xlim=c(0, xmax), ylim=c(0.5,ymax), asp=1, frame.plot = FALSE)
  text(x = median(positions$x/2), y = 1.5*ycol/2 ,  labels= title, cex=1.3)
  
  for(i in 1:length(positions$y)){
    for(j in 1:length(positions$x)){
      
      x <- positions$x[j] / 2
      fitn = positions$zname[j]
      
      disp = positions$yname[i]
      y <- positions$y[i] / 2
      
      k <- length(positions$x)*(i-1) + j
      
      mpv <- mean(z[,k])
      shape::filledrectangle(wx = 0.3 ,wy = 0.3, col = Cols[which.max(index[index <= mpv])],
              mid = c(x, y), angle = 0, lcol = "darkgrey")
      
      xval <- (lengths - min(lengths)) / lRange *0.3 -0.15
      yval <- z[,k] * 0.3 - 0.15
      yUP <- zCIUP[,k] * 0.3 - 0.15 
      yLOW <- zCILOW[,k] * 0.3 - 0.15
      
      polygon(c(x+xval, rev(x+xval)), c(y+yUP, rev(y+yLOW)), col = "#99999940", border = NA)
      lines(x+xval, y+yval)
      lines(c(x-0.15,x-0.13) , c(y , y ))
      lines(c(x+0.13,x+0.15) , c(y , y ))
    }
  }
  
  text(x = -0.26*min(positions$x), y = positions$y/2, labels = positions$yname , pos = 4) 
  text(x = positions$x/2, y = 1.2*ycol/2, labels =  positions$zname ) 
  text(x = positions$x/2, y = 0,  labels= positions$xname)
  
  barx <- max(positions$x)/2+ min(positions$x)/2
  bary <- mean(positions$y)/2
  barl <- 0.3
  
  fields::colorbar.plot(x = barx, y = bary, strip=seq(0,1,0.001), col=Cols, 
                        strip.length = barl, horizontal = F, strip.width = 0.04)
  text(x = barx+0.1 , y = bary + 1.8* barl, labels = "overdispersed" , pos = 4) 
  text(x = barx+0.1 , y = bary, labels = "neutral" , pos = 4) 
  text(x = barx+0.1 , y = bary - 1.8* barl, labels = "underdispersed \n(clustered)", pos = 4) 
  
  par(.pardefault)
}


